/*******************************************************************************
 * \file asclin0.c
 * \brief serial interface details
 * \copyright Copyright (C) Infineon Technologies AG 2019
 *
 * Use of this file is subject to the terms of use agreed between (i) you or
 * the company in which ordinary course of business you are acting and (ii)
 * Infineon Technologies AG or its licensees. If and as long as no such terms
 * of use are agreed, use of this file is subject to following:
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer, must
 * be included in all copies of the Software, in whole or in part, and all
 * derivative works of the Software, unless such copies or derivative works are
 * solely in the form of machine-executable object code generated by a source
 * language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 ******************************************************************************/
#include "Ifx_Types.h"
#include "IfxCpu.h"
#include "Ifx_reg.h"
#include "ifxScuWdt.h"

#include "intpriodef.h"
#include "ports.h"

#include "asclin_private.h"
#include "dma_private.h"
#include "asclin3_public.h"

#define ASCLIN3_RXBUF_SIZE ((uint16)200u) /**< \brief */
#define ASCLIN3_TXBUF_SIZE ((uint16)200u) /**< \brief */

/** \addtogroup Asclin_Variables */
/* private data */
static uint8  ASCLIN3_txBusy;
static volatile uint16 ASCLIN3_rxReceiveCount;
static volatile uint16 ASCLIN3_txSendCount;
static volatile uint16 ASCLIN3_errorCount;
static volatile uint16 ASCLIN3_txDmaCnt;
static volatile uint16 ASCLIN3_rxDmaCnt;

static uint16 ASCLIN3_txHeadIdx;
static uint16 ASCLIN3_rxHeadIdx;
static uint16 ASCLIN3_txTailIdx;
static uint16 ASCLIN3_rxTailIdx;

uint8 txData[ASCLIN3_TXBUF_SIZE];
uint8 rxData[ASCLIN3_RXBUF_SIZE];

/* private functions */
void ASCLIN3_TxISR(void);
void ASCLIN3_RxISR(void);
void ASCLIN3_ErrorISR(void);
void ASCLIN3_DMA_Init(uint16 trel);

/* global functions */

/** \brief
 *
 * \param None
 * \return Nothing
 *
 * \ingroup
 */
void ASCLIN3_Init (void)
{
    uint16 cpuPassword = IfxScuWdt_getCpuWatchdogPassword();
    IfxScuWdt_clearCpuEndinit(cpuPassword);
    ASCLIN3_CLC.U = 0; /* enable peripheral and allow sleep mode */
    (void) ASCLIN3_CLC.U;
#if 0
    /* change the driver strength on the port transmit pin */
    P15_PDR0.U = 0;
#else
    /* change the driver strength on the port transmit pin */
    P00_PDR0.U = 0;
#endif

    /* Kernel reset */
    ASCLIN3_KRST0.U = 0x01;
    ASCLIN3_KRST1.U = 0x01;
    IfxScuWdt_setCpuEndinit(cpuPassword);

    while ((ASCLIN3_KRST0.U & 0x02) != 0x02)
        ;
    IfxScuWdt_clearCpuEndinit(cpuPassword);
    ASCLIN3_KRSTCLR.U = 0x01; /* Clear Reset done flag */
    IfxScuWdt_setCpuEndinit(cpuPassword);

#if 0
    /* ASC1_ATX / P15.4 transmit output is O2  */
    P15_IOCR4.B.PC4 = Port_PCx_Output_PushPull_Alt_2;
    /* ASC1_ARX1B / P15.5  */
    P15_IOCR4.B.PC5 = Port_PCx_Input_PullUp;
#else
    /* ASCLIN3_ATX P00.0 transmit output is O3 */
    P00_IOCR0.B.PC0 = PCx_Output_PushPull_Alt_3;
    /* ASCLIN3_ARXG P00.1 receive pin*/
    P00_IOCR0.B.PC1 = PCx_Input_PullUp;
#endif

    Ifx_ASCLIN_IOCR iocr =
    {
#if 0
      .B.ALTI = asclin_iocr_RxInputSelect_ARXnB,
#else
      .B.ALTI = asclin_iocr_RxInputSelect_ARXnE,
#endif
      .B.DEPTH = 0, /*0=off, 1 to 63 */
      .B.CTS = asclin_iocr_CtsInputSelect_0,
      .B.RCPOL = asclin_iocr_RtsCtsPolarity_activeHigh,
      .B.CPOL = asclin_iocr_ClockPolaritySyncMode_idleLow,
      .B.SPOL = asclin_SlavePolaritySyncModeSlsoIdleLow,
      .B.LB = asclin_iocr_LoopBackModeDisabled,
      .B.CTSEN = asclin_iocr_CTS_disabled,
    };
    ASCLIN3_IOCR.U = iocr.U;

    Ifx_ASCLIN_TXFIFOCON txfifocon = {
        .B.FLUSH = asclin_txfifocon_Flushed,
        .B.ENO = asclin_txfifocon_OutletEnabled,
        .B.INW = asclin_txfifocon_InletWidth_1,
        .B.INTLEVEL = asclin_txfifocon_InterruptLevel_15,
    };
    ASCLIN3_TXFIFOCON.U = txfifocon.U;

    Ifx_ASCLIN_RXFIFOCON rxfifocon = {
      .B.FLUSH = asclin_rxfifocon_Flushed,
      .B.ENI = asclin_rxfifocon_InletEnabled,
      .B.OUTW = asclin_rxfifocon_OutletWidth_1,
      .B.INTLEVEL = asclin_rxfifocon_InterruptLevel_1,
      .B.BUF = asclin_rxfifocon_ReceiveBufferMode_rxFifo,
    };
    ASCLIN3_RXFIFOCON.U = rxfifocon.U;

    Ifx_ASCLIN_BITCON bitcon = {
      .B.SM = asclin_SamplesPerBit_three,
      .B.SAMPLEPOINT = asclin_SamplePointPosition_9,
      .B.OVERSAMPLING = asclin_OversamplingFactor_16,
      .B.PRESCALER = 0,
    };
    ASCLIN3_BITCON.U = bitcon.U;

    Ifx_ASCLIN_FRAMECON framecon = {
      .B.ODD = asclin_ParityType_even,
      .B.PEN = asclin_ParityEnable_Disabled,
      .B.CEN = asclin_CollisionDetection_Disabled,
      .B.MSB = asclin_ShiftDirection_lsbFirst,
      .B.MODE = asclin_frameMode_initialise,
      .B.LEAD = asclin_LeadDelay_0,
      .B.STOP = asclin_StopBit_1,
      .B.IDLE = asclin_IdleDelay_0,
    };
    ASCLIN3_FRAMECON.U = framecon.U;

    Ifx_ASCLIN_DATCON datcon = {
      .B.RESPONSE = 0,
      .B.CSM = asclin_Checksum_classic,
      .B.RM = asclin_LinResponseTimeoutMode_frameTimeout,
      .B.HO = asclin_HeaderResponseSelect_headerAndResponse,
      .B.DATLEN = asclin_DataLength_8,
    };
    ASCLIN3_DATCON.U = datcon.U;

    /*  */
    Ifx_ASCLIN_BRG brg = {
      .B.NUMERATOR = 37,
      .B.DENOMINATOR = 4015,
    };
    ASCLIN3_BRG.U = brg.U;

    /* Clear all Flags */
    ASCLIN3_FLAGSCLEAR.U = 0xFFFFFFFF;

    Ifx_ASCLIN_FLAGSENABLE flagenable = {
      .B.TFLE = TRUE, /* Transmit FIFO Level */
      .B.TFOE = TRUE, /* Transmit FIFO Overflow */
      .B.RFLE = TRUE, /* Receive FIFO Level */
      .B.RFUE = TRUE, /* Receive FIFO Underflow */
      .B.RFOE = TRUE, /* Receive FIFO Overflow */
      .B.FEE = TRUE,  /* Framing Error */
    };
    ASCLIN3_FLAGSENABLE.U = flagenable.U;

#if 0 // use interrupts
    SRC_ASCLIN3TX.U =  TOS_CPU0 | SRE_ON | SRPN_CPU0_ASCLIN3_TX;
    SRC_ASCLIN3RX.U =  TOS_CPU0 | SRE_ON | SRPN_CPU0_ASCLIN3_RX;
#else // use DMA
    SRC_ASCLIN3TX.U = TOS_DMA | SRE_ON | SRPN_DMA_CH_QSPI3_TX;
    SRC_ASCLIN3RX.U = TOS_DMA | SRE_ON | SRPN_DMA_CH_QSPI3_RX;

#endif
    SRC_ASCLIN3ERR.U = TOS_CPU0 | SRE_ON | SRPN_CPU0_ASCLIN3_ER;

    ASCLIN3_FRAMECON.B.MODE = asclin_frameMode_asc;
    ASCLIN3_txSendCount = 0;
    ASCLIN3_txBusy = 0;
    ASCLIN3_txHeadIdx = 0;
    ASCLIN3_rxHeadIdx = 0;
    ASCLIN3_txTailIdx = 0;
    ASCLIN3_rxTailIdx = 0;

    Ifx_ASCLIN_CSR csr = {
      .B.CLKSEL = asclin_csr_ClockSource_fASCLINF,
      .B.CON = asclin_csr_ClockIsOn,
    };
    ASCLIN3_CSR.U = csr.U;

    for (uint32 i=0; i < 200;i++)
      txData[i] = (uint8)i;

    ASCLIN3_DMA_Init(10);
}


/** \addtogroup
 * \{ */

/** \brief
 *
 * \param None
 * \return Nothing
 *
 * \ingroup Asclin_msg
 */
void ASCLIN3_SendCmdMsg(void)
{
	ASCLIN3_TXDATA.U = txData[0];
}

/** \addtogroup Asclin_InterruptFunctions
 * \{ */

/** \brief ASCLIN0 Transmit interrupt handler
 *
 * \param None
 * \return Nothing
 *
 * \ingroup Asclin_msg
 */
IFX_INTERRUPT(ASCLIN3_TxISR, VECTAB0, SRPN_CPU0_ASCLIN3_TX);
void ASCLIN3_TxISR(void)
{
	if (ASCLIN3_txSendCount > 0)
	{
		ASCLIN3_txSendCount--;
		ASCLIN3_TXDATA.U = txData[ASCLIN3_txTailIdx++];
		ASCLIN3_txTailIdx = ASCLIN3_txTailIdx & (ASCLIN3_TXBUF_SIZE - 1);
	}
	else
	{
		ASCLIN3_txBusy = FALSE;
	}
}

/** \brief ASCLIN0 Receive interrupt handler
 *
 * \param None
 * \return Nothing
 *
 * \ingroup Asclin_msg
 */
IFX_INTERRUPT(ASCLIN3_RxISR, VECTAB0, SRPN_CPU0_ASCLIN3_RX);
void ASCLIN3_RxISR(void)
{
	/* indicated to the software loop we have data waiting in the software receive buffer */
	ASCLIN3_rxReceiveCount++;

	/* read received data into the ring buffer clearing the CMD bit */
	rxData[ASCLIN3_rxHeadIdx++] = (uint8) ASCLIN3_RXDATA.U;

	/* increment the head pointer of the receive ring buffer */
	ASCLIN3_rxHeadIdx = ASCLIN3_rxHeadIdx & (ASCLIN3_RXBUF_SIZE - 1);
}

/** \brief ASCLIN0 Error interrupt handler
 *
 * \param None
 * \return Nothing
 *
 * \ingroup Asclin_msg
 */
IFX_INTERRUPT(ASCLIN3_ErrorISR, VECTAB0, SRPN_CPU0_ASCLIN3_ER);
void ASCLIN3_ErrorISR(void)
{
	ASCLIN3_errorCount++;
}


/** \brief
 *
 * \param None
 * \return None
 *
 *  \ingroup
 */
static inline void ASCLIN3_PutDataTxBuf(uint16 value)
{
	txData[ASCLIN3_txHeadIdx++] = (uint8) value;
	ASCLIN3_txHeadIdx = ASCLIN3_txHeadIdx & (ASCLIN3_TXBUF_SIZE - 1);
	ASCLIN3_txSendCount++;
}


/** \brief
 *
 * \param None
 * \return None
 *
 *  \ingroup
 */
void ASCLIN3_SetData(uint8 *src, uint8 len)
{
	/* load message */
	for (; len; len--)
	{
		ASCLIN3_PutDataTxBuf(*src++);
	}

	if (ASCLIN3_txBusy == FALSE)
	{
		/* ASCLIN is now busy */
  	ASCLIN3_txBusy = TRUE;
		/* we are sending a data, we need to indicate it here, remaining is done in the ISR */
		ASCLIN3_txSendCount--;
		/* write to SPI transmit data register */
		ASCLIN3_TXDATA.U = txData[ASCLIN3_txTailIdx++];
		/* check for the buffer wrap around */
		ASCLIN3_txTailIdx = ASCLIN3_txTailIdx & (ASCLIN3_TXBUF_SIZE - 1);
	}

}

void ASCLIN3_DMA_Init(uint16 trel)
{
    /* DMA Channel 005 used for Transmit */
    DMA_SADR005.U = (uint32)&txData[0];
    DMA_DADR005.U = (uint32)&ASCLIN3_TXDATA.U;

    Ifx_DMA_CH_CHCFGR chcfgr_5 = {
        .B.TREL = trel,    /*Transfer Reload Value */
        .B.BLKM = dma_chcfgrxxx_blkm_OneTransferHasOneMove,
        .B.RROAT = dma_chcfgrxxx_rroat_ResetAfterEachTransfer,
        .B.CHMODE = dma_chcfgrxxx_chmode_SingleMode,
        .B.CHDW = dma_chcfgrxxx_chdw_DataBitWidth_8,
        .B.PATSEL = dma_chcfgrxxx_patsel_NoPatternCompareOperation,
        .B.PRSEL = dma_chcfgrxxx_prsel_HardwareRequestSelected,
        .B.DMAPRIO = dma_chcfgrxxx_dmaprio_LowPrioritySelected,
    };
    DMA_CHCFGR005.U = chcfgr_5.U;

Ifx_DMA_CH_ADICR adicr_5 = {
        .B.SMF = dma_adicrxxx_smf_AddressOffsetIsCHDWx1,
        .B.INCS = dma_adicrxxx_incs_AddressOffsetIsAdded,
        .B.DMF = dma_adicrxxx_dmf_AddressOffsetIsCHDWx1,
        .B.INCD = dma_adicrxxx_incd_AddressOffsetIsSubtracted,
        .B.CBLS = dma_adicrxxx_cbls_SourceAddress31to0,
        .B.CBLD = dma_adicrxxx_cbld_DestinationAddress31to0,
        .B.SHCT = dma_adicrxxx_shct_MoveOperation,
        .B.SCBE = dma_adicrxxx_scbe_SourceCircularBufferDisabled,
        .B.DCBE = dma_adicrxxx_dcbe_DestinationCircularBufferEnabled,
        .B.STAMP = dma_adicrxxx_stamp_NoAction,
        .B.ETRL = dma_adicrxxx_etrl_NoInterruptOnLostEvent,
        .B.WRPSE = dma_adicrxxx_wrpse_WrapSourceBufferInterruptTriggerDiabled,
        .B.WRPDE = dma_adicrxxx_wrpde_WrapDestinationBufferInterruptTriggerDiabled,
        .B.INTCT = dma_adicrxxx_intct_InterruptChangingTCOUNTandEqualsIRDV,
        .B.IRDV = 0,  /*Interrupt Raise Detect Value*/
    };
    DMA_ADICR005.U = adicr_5.U;
    DMA_TSR005.B.ECH = 1;

/* DMA Channel 006: used for Receive */
    DMA_SADR006.U = (uint32)&ASCLIN3_RXDATA.U;
    DMA_DADR006.U = (uint32)&rxData[0];

    Ifx_DMA_CH_CHCFGR chcfgr_6 = {
        .B.TREL = trel, /*Transfer Reload Value */
        .B.BLKM = dma_chcfgrxxx_blkm_OneTransferHasOneMove,
        .B.RROAT = dma_chcfgrxxx_rroat_ResetAfterEachTransfer,
        .B.CHMODE = dma_chcfgrxxx_chmode_SingleMode,
        .B.CHDW = dma_chcfgrxxx_chdw_DataBitWidth_8,
        .B.PATSEL = dma_chcfgrxxx_patsel_NoPatternCompareOperation,
        .B.PRSEL = dma_chcfgrxxx_prsel_HardwareRequestSelected,
        .B.DMAPRIO = dma_chcfgrxxx_dmaprio_LowPrioritySelected,
    };
    DMA_CHCFGR006.U = chcfgr_6.U;

Ifx_DMA_CH_ADICR adicr_6 = {
        .B.SMF = dma_adicrxxx_smf_AddressOffsetIsCHDWx1,
        .B.INCS = dma_adicrxxx_incs_AddressOffsetIsSubtracted,
        .B.DMF = dma_adicrxxx_dmf_AddressOffsetIsCHDWx1,
        .B.INCD = dma_adicrxxx_incd_AddressOffsetIsAdded,
        .B.CBLS = dma_adicrxxx_cbls_SourceAddress31to0,
        .B.CBLD = dma_adicrxxx_cbld_DestinationAddress31to0,
        .B.SHCT = dma_adicrxxx_shct_MoveOperation,
        .B.SCBE = dma_adicrxxx_scbe_SourceCircularBufferEnabled,
        .B.DCBE = dma_adicrxxx_dcbe_DestinationCircularBufferDisabled,
        .B.STAMP = dma_adicrxxx_stamp_NoAction,
        .B.ETRL = dma_adicrxxx_etrl_NoInterruptOnLostEvent,
        .B.WRPSE = dma_adicrxxx_wrpse_WrapSourceBufferInterruptTriggerDiabled,
        .B.WRPDE = dma_adicrxxx_wrpde_WrapDestinationBufferInterruptTriggerDiabled,
        .B.INTCT =dma_adicrxxx_intct_InterruptChangingTCOUNTandEqualsIRDV,
        .B.IRDV = 0,  /*Interrupt Raise Detect Value*/
    };
    DMA_ADICR006.U = adicr_6.U;
    DMA_TSR006.B.ECH = 1;

/* Setup interrupt from DMA Channel 5 and 6 when the Move Transaction has finished */
    SRC_DMACH5.U = TOS_CPU0 | SRE_ON | SRPN_CPU0_DMA_CH5;
    SRC_DMACH6.U = TOS_CPU0 | SRE_ON | SRPN_CPU0_DMA_CH6;
}


IFX_INTERRUPT(ASCLIN3_DMA_CH5, VECTAB0, SRPN_CPU0_DMA_CH5);
void ASCLIN3_DMA_CH5(void)
{
  ASCLIN3_txDmaCnt++;
}


IFX_INTERRUPT(ASCLIN3_DMA_CH6, VECTAB0, SRPN_CPU0_DMA_CH6);
void ASCLIN3_DMA_CH6(void)
{
  ASCLIN3_rxDmaCnt++;
}

/** \} */

/*************************************************************************
 Development history of the file



*************************************************************************/
